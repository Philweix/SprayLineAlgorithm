<!DOCTYPE html>
<html lang="en">
<head>
    <title>Spray Line Algorithm</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="./css/main.css">
</head>

<body>

<script type="module">
    import * as THREE from './js/three.module.js';
    import { GUI } from './js/lil-gui.module.min.js';
    import { OrbitControls } from './js/OrbitControls.js';
    import { GLTFLoader } from './js/GLTFLoader.js';
    import { RGBELoader } from './js/RGBELoader.js';

    let camera, scene, renderer, object, object1, robotPosition1, robotPosition2, robot1, robot2, controlsOne;

    const clipPlanes = [
        new THREE.Plane( new THREE.Vector3( 1, 0, 0 ), -13 ),
        new THREE.Plane( new THREE.Vector3( - 1, 0, 0 ), 13 ),

    ];

    init();
    render();

    function init() {
        const container = document.createElement( 'div' );
        document.body.appendChild( container );
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100000 );
        camera.position.set( 14, -20, 10 );
        camera.up.set(0,0,1);
        scene = new THREE.Scene();
        window.scene = scene;

        new RGBELoader()
            .setPath( './textures/' )
            .load( 'royal_esplanade_1k.hdr', function ( texture ) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                // scene.background = new THREE.Color("rgb(0, 30, 116)");
                scene.background = new THREE.Color("withe");
                scene.environment = texture;

                loadLeePerrySmith();
            } );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild( renderer.domElement );
        renderer.localClippingEnabled = true

        const controls = new OrbitControls( camera, renderer.domElement );
        controls.minDistance = 2;
        controls.maxDistance = 10000;
        controls.target.set( 0, 0, - 0.2 );
        controls.update();

        window.addEventListener( 'resize', onWindowResize );

    }

    function loadLeePerrySmith() {

        const loader = new GLTFLoader();

        let flag = 0;
        let modelListUse = {
            'CRRC_Spray_Move': null,
            'CRRC_Spray_Car01': null,
            'CRRC_Spray_Car02': null,
            'CRRC_Spray_Plane': null
        }
        let modelNameList = ['CRRC_Spray_Move', 'CRRC_Spray_Car01', 'CRRC_Spray_Car02',  'CRRC_Spray_Plane']

        for (let i = 0; i < modelNameList.length; i ++){
            loader.load( 'models/' + modelNameList[i] + '.glb', function ( gltf ) {
                let modelMesh = gltf.scene.children[ 0 ];
                scene.add( modelMesh );
                flag ++;
                if(flag === modelNameList.length){
                    for ( const model in modelListUse ) {
                        modelListUse[model] = getObjectByName(model);
                    }
                    object = modelListUse['CRRC_Spray_Move'].children[0].children[15];
                    object.material.clippingPlanes = [ clipPlanes[1] ];

                    object1 = modelListUse['CRRC_Spray_Move'].children[0].children[15].clone();
                    object1.material = modelListUse['CRRC_Spray_Move'].children[0].children[15].material.clone();
                    object1.material.color.setRGB( 0.01, 0.199, 0.22 );
                    object1.material.clippingPlanes = [ clipPlanes[0] ];
                    modelListUse['CRRC_Spray_Move'].children[0].add( object1 );
                    robot1 = modelListUse['CRRC_Spray_Car01'].children[32];
                    robot2 = modelListUse['CRRC_Spray_Car02'].children[32];
                    robotPosition1 = modelListUse['CRRC_Spray_Car01'].children[32].position.x;
                    robotPosition2 = modelListUse['CRRC_Spray_Car02'].children[32].position.x;
                    controlsOne = robot1.material.color.getStyle();

                    const gui = new GUI();
                    const params = {
                        planeConstant: 13,
                        carBefore: object.material.color.getStyle(),
                        carAfter: object1.material.color.getStyle(),
                    };
                    gui.add( params, 'planeConstant', - 11, 13 ).step( 0.01 ).name( 'clipPlanesPosition' ).onChange( function ( value ) {

                        clipPlanes[ 0 ].constant = -value;
                        clipPlanes[ 1 ].constant = value;
                        // Return to the same car body color
                        // if( value < oldValue ){
                        //     clipPlanes[ 0 ].constant = -value;
                        //     clipPlanes[ 1 ].constant = value;
                        //     oldValue = value;
                        // }
                        robot1.position.x = robotPosition1 - ( 13 - value ) * 10;
                        robot2.position.x = robotPosition2 - ( 13 - value ) * 10;

                    } );
                    gui.addColor(params, 'carBefore').onChange(function (e) {
                        object.material.color.setStyle(e);
                    });
                    gui.addColor(params, 'carAfter').onChange(function (e) {
                        object1.material.color.setStyle(e);
                    });

                }

            } );
        }


    }

    function getObjectByName(name){
        let modelGet = null
        scene.traverse(res => {
            if(res.name === name) modelGet = res
        })
        return modelGet
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    //

    function render() {
        requestAnimationFrame( render );
        renderer.render( scene, camera );
    }

</script>

</body>
</html>
